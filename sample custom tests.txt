		System.out.println("Brute Force tests:");
		Word testString = new Word("x+x");
		Word testString1 = new Word("1+0");
		Word testString2 = new Word("01");
		Word testString3 = new Word("*-*");
		System.out.println(parser.isInLanguage(cfg, testString));
		System.out.println(parser.isInLanguage(cfg, testString1));
		System.out.println(parser.isInLanguage(cfg, testString2));
		System.out.println(parser.isInLanguage(cfg, testString3));
		
		System.out.println("CYK Tests:");
		testString1 = new Word("1*-0*-1+0*-1");
		testString1 = new Word("0+-1*-0+1*1");
		testString2 = new Word("1*0+--1+0*1");
		testString3 = new Word("1*0+0-1+1+0+-0");
		System.out.println(parser.isInLanguage(cfg, testString));
		System.out.println(parser.isInLanguage(cfg, testString1));
		System.out.println(parser.isInLanguage(cfg, testString2));
		System.out.println(parser.isInLanguage(cfg, testString3));
		
		System.out.println("Tree generation Tests:");
		System.out.println(parser.generateParseTree(cfg, testString));



		
                System.out.print("Moving: ");
                System.out.print(i-1);
                System.out.print(" ");
                System.out.print(i-1+addition);
                System.out.print(" To: ");
                System.out.print(i-1);
                System.out.print(" ");
                System.out.print(i+addition);
                System.out.println();


								   System.out.print("Moving: ");
                System.out.print(i-1);
                System.out.print(" ");
                System.out.print(i-1+addition);
                System.out.print(" To: ");
                System.out.print(i-1);
                System.out.print(" ");
                System.out.print(i+addition);
                System.out.print(" And: ");
                System.out.print(i-2);
                System.out.print(" ");
                System.out.print(i-1+addition);
                System.out.println();


 public void genParseTree(ContextFreeGrammar cfg,Word w){
    if(isInLanguage(cfg, w)){
      List<Rule> rules = cfg.getRules();
      int lengthOfWord = w.length();
      Symbol stVar = cfg.getStartVariable();
      Boolean didIMergeRules = false;
      ArrayList<ArrayList<ArrayList<Symbol>>> diagonals = new ArrayList<>();
      //Create new instance
      for(int i=0; i<lengthOfWord;i++){
        diagonals.add(new ArrayList<>(lengthOfWord));
        for(int j=0; j<lengthOfWord;j++){
          diagonals.get(i).add(new ArrayList<>());
        }
      }
      //Populate first row

      for(int i=0;i<lengthOfWord;i++){
        for(int index = 0; index<GlobalSymbolTable.get(i).get(i).size();index++){
          if(GlobalSymbolTable.get(i).get(i).size() > 0){
            diagonals.get(0).get(i).add(GlobalSymbolTable.get(i).get(i).get(index));
          }
        }
      }
      for(int i=0;i<diagonals.size()-1;i++){ //loop
        for(int index = 0; index<diagonals.get(i).size()-1;index++){
          if(didIMergeRules == true){
            didIMergeRules = false;
            continue;
          }
          for(Rule rule : rules){
            for(Symbol testSymbol1 : diagonals.get(i).get(index)){
              for(Symbol testSymbol2 : diagonals.get(i).get(index+1)){
                if(rule.getExpansion().get(0)==testSymbol1 && rule.getExpansion().get(1) == testSymbol2){
                  diagonals.get(i+1).get(index).add(rule.getVariable());
                  didIMergeRules = true;
                }
              }
            }
          }
          if(didIMergeRules != true){
            for(Symbol symbolToMove : diagonals.get(i).get(index)){
              diagonals.get(i+1).get(index).add(symbolToMove);
            }            
          }
        }
        while(isThereGap(diagonals.get(i+1))){
          //Shift elements to be adjacent
          for(int nextIndex = 0; nextIndex<diagonals.get(i+1).size()-1;nextIndex++){
            if(diagonals.get(i+1).get(nextIndex).isEmpty()){
              for(int elementIndex = diagonals.get(i+1).get(nextIndex+1).size() - 1; elementIndex >= 0; elementIndex--){
                diagonals.get(i+1).get(nextIndex).add(diagonals.get(i+1).get(nextIndex+1).get(elementIndex));
                diagonals.get(i+1).get(nextIndex+1).remove(elementIndex);
                didIMergeRules=false;
              }
            }
          }
        }
      } //loop
    }
  }



//generateParseTree
public ParseTreeNode generateParseTree(ContextFreeGrammar cfg, Word w) {
    try{
      
      System.out.println(GlobalSymbolTable);
      //Check if word is in language
      if(isInLanguage(cfg,w)){
        List<Rule> rules = cfg.getRules();
        int lengthOfWord = w.length();
        Symbol stVar = cfg.getStartVariable();
        //Start building parse trees
        for(int addition=0;addition<lengthOfWord-1;addition++){
          int bounds = lengthOfWord-1;
          for(int i=1;i<lengthOfWord;i++){
            if(i+addition > bounds){
              continue;
            }
            //If the current cell is not empty, get the children and build a parse tree
            if(GlobalParseTreeTable.get(i-1).get(i+addition).size() > 1){
              ParseTreeNode node1 =  new ParseTreeNode(nullSymbol);
              ParseTreeNode node2 =  new ParseTreeNode(nullSymbol);
              //Loop through all the rules to check if the cell we are in generated the children
              for(Rule rule : rules){
                //Build a combination of all possible outcomes
                for(Symbol thisSymbol : validSymbolList(stVar,i-1,i+addition)){
                  for(Symbol child1Symbol : validSymbolList(stVar,i-1,i-1+addition)){
                    for(Symbol child2Symbol : validSymbolList(stVar,i,i+addition)){
                      if(rule.getVariable() == thisSymbol && rule.getExpansion().get(0)==child1Symbol && rule.getExpansion().get(1) == child2Symbol){
                        //If we got here then the symbol of the rule, thisSymbol expands to form child1 and child2. Since we have their coords
                        //we can build a parse tree node
                        node1 = treeFromSymbol(child1Symbol,i-1,i-1+addition);
                        node2 = treeFromSymbol(child2Symbol,i,i+addition);
                        ParseTreeNode newNode = new ParseTreeNode(thisSymbol,node1,node2);
                        GlobalParseTreeTable.get(i-1).get(i+addition).add(newNode);
                      }
                    }
                  }
                }
              }
            //If the current cell is empty
            } else{
              //We have several possibilites that got us here. We could be at the edges meaning we have to
              //move the previous cell accordingly. If we are at a top edge we need to move the cell to our left
              //on us. If we are at a right edge we need to move the cell below us to us. 
              //Since we are moving diagonally, when i=1 we are at top, and when i=lengthOfWord-1 we are at right
              if(i == 1){
                cellMoveParseTree(i-1, i+addition, i-1, i-1+addition, this.GlobalParseTreeTable, this.GlobalParseTreeTable);
                cellClearSymbol(i-1, i-1+addition, this.GlobalParseTreeTable);
              }              
              if(i!=lengthOfWord-1 && i > 1){
                cellMoveParseTree(i-1, i+addition, i-1, i-1+addition, this.GlobalParseTreeTable, this.GlobalParseTreeTable);
                cellMoveParseTree(i-1, i-1+addition, i, i-1+addition, this.GlobalParseTreeTable, this.GlobalParseTreeTable);
                cellClearSymbol(i-1, i-1+addition, this.GlobalParseTreeTable);
              }

              if(i==lengthOfWord-1){
                cellMoveParseTree(i-1, i+addition, i, i+addition, this.GlobalParseTreeTable, this.GlobalParseTreeTable);
                cellClearSymbol(i, i+addition, this.GlobalParseTreeTable);
              }
            }
          }
        }//Loop end
        ParseTreeNode terminalNode = new ParseTreeNode(nullSymbol);
        ParseTreeNode terminalNode2 = new ParseTreeNode(nullSymbol);
        ParseTreeNode finalParseTree = new ParseTreeNode(nullSymbol);
        for(Rule rule : rules){
          //This is the rule we want
          if(rule.getVariable() == stVar){
            if (rule.getExpansion().toString() == "Îµ"){
              continue;
            }
            for(int i=0;i<GlobalParseTreeTable.get(0).get(lengthOfWord-2).size();i++){
              for(int j=0;j<GlobalParseTreeTable.get(1).get(lengthOfWord-1).size();j++){
                terminalNode = (ParseTreeNode)GlobalParseTreeTable.get(0).get(lengthOfWord-2).get(i);
                terminalNode2 = (ParseTreeNode)GlobalParseTreeTable.get(1).get(lengthOfWord-1).get(j);
                Symbol child1Symbol = terminalNode.getSymbol();
                Symbol child2Symbol = terminalNode2.getSymbol();
                for(int ruleindex=0; ruleindex < rule.getExpansion().length()-1 ; ruleindex++){
                  if(rule.getExpansion().get(ruleindex)==child1Symbol && rule.getExpansion().get(ruleindex+1) == child2Symbol){
                    terminalNode = treeFromSymbol(child1Symbol,0,lengthOfWord-2);
                    terminalNode2 = treeFromSymbol(child2Symbol,1,lengthOfWord-1);
                    finalParseTree = new ParseTreeNode(stVar,terminalNode,terminalNode2);
                  }
                }
              }
            }  
          }   
        }
        return finalParseTree;
      }
      return null;
    }catch(Exception e){
      System.out.println("Error in CYK tree generation : " + e);
      return null;
    }
  }
